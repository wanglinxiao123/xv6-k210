# 外设与地址对应关系
|起始地址|长度|外设名|
|---|---|---|
|0x02000000|0x1000|CLINT|
|0x0C200000|0x1000|PLIC|
|0x38000000|0x1000|UARTHS|
|0x38001000|0x1000|GPIOHS|
|0x50000000|0x1000|DMAC|
|0x50200000|0x1000|GPIO|
|0x50240000|0x1000|SPI_SLAVE|
|0x502B0000|0x1000|FPIOA|
|0x502D0000|0x1000|TIMER0|
|0x502E0000|0x1000|TIMER1|
|0x502F0000|0x1000|TIMER2|
|0x50440000|0x1000|SYSCTL|
|0x52000000|0x1000|SPI0|
|0x53000000|0x1000|SPI1|
|0x54000000|0x1000|SPI2|
|0x80000000|0x600000|SRAM|



# 页表操作函数
```c
// 初始化内核页表，映射外设地址、内核段、数据段、TRAMPOLINE
void kvminit()
// 刷新 CPU 使用的页表
void kvminithart()

// ---------------------------------
// 创建页表
// ---------------------------------

// 创建一个页表
pagetable_t uvmcreate()

// ---------------------------------
// 通过页表将虚拟地址转换为物理地址
// ---------------------------------

// 根页表为 pagetable，找到 va 对应的页表项物理地址
// alloc = 1 则分配空间
pte_t* walk(pagetable_t pagetable, uint64 va, int alloc)

// 从页表 pagetable 中找到 va 对应的 pa
// 页表项必须具备 PTE_V | PTE_U
uint64 walkaddr(pagetable_t pagetable, uint64 va)

// 获取 (kernel_pagetable, va) 对应的 pa
uint64 kvmpa(uint64 va)


// ---------------------------------
// 将页表中的虚拟地址 (pagetable, va, size) 映射到物理地址 (pa, size)
// ---------------------------------

// 将(pagetable, va, size) 映射到 (pa, size)
// 设置 PTE_V | perm
int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) 

// 将 (pa, size) 映射到 (kernel_pagetable, va, size)
// 设置 perm | PTE_V
// 调用 mappages()
void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)

// 分配一页物理页，将 (src, sz) 拷贝到物理页中
// (pagetable, 0, sz) 和 (kpagetable, 0, sz) 都映射到该物理页
void uvminit(pagetable_t pagetable, uchar *src, uint sz)


// ---------------------------------
// 取消映射与释放空间
// ---------------------------------

// 取消(pagetable, va, npages) 的映射
// do_free = 1 则释放物理页面的空间
void vmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)

// 递归删除页表 pagetable 所占用的空间
// 并不释放页表映射的物理页面
void freewalk(pagetable_t pagetable)

// 删除 (pagetable, sz) 的物理页映射，回收物理页内存
// 递归删除所有的页表
void uvmfree(pagetable_t pagetable, uint64 sz)


// ---------------------------------
// 空间动态调整
// ---------------------------------

// 将 pagetable 和 kpagetable 的大小从 oldsz 增长到 newsz
// 分配页表的同时映射物理页
uint64 uvmalloc(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)


// 将 pagetable 和 kpagetable 的大小从 oldsz 减小到 newsz
// 对于 kpagetable 只取消映射、对于 pagetable 取消映射且释放物理页面
uint64 uvmdealloc(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)



// ---------------------------------
// 页表复制
// ---------------------------------

// 根据 (old, sz) 申请新的物理页，并填充同样的数据
// 将这片物理页映射到页表 new 和 knew
int uvmcopy(pagetable_t old, pagetable_t new, pagetable_t knew, uint64 sz)

// ---------------------------------
// 权限管理
// ---------------------------------

// 清除(pagetable, va) 页表项的 PTE_U
void uvmclear(pagetable_t pagetable, uint64 va)

// ---------------------------------
// 内存复制，将内存中的 物理地址 拷贝到 页表对应的虚拟地址
// ---------------------------------

// 将(src, len) 拷贝到 (pagetable, dstva, len)
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)

// 将 (pagetable, srcva, len) 拷贝到 (dst, len)
int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)

// 将 (pagetable, srcva, max) 拷贝到 (dst, max)
// 遇到 '\0' 则终止
int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)


// ---------------------------------
// 内存复制，将内存中的 物理地址 拷贝到 另一个物理地址
// ---------------------------------

// 将 (src, len) 拷贝到 (dstva, len)
int copyout2(uint64 dstva, char *src, uint64 len)

// 将 (srcva, len) 拷贝到 (dst, len)
int copyin2(char *dst, uint64 srcva, uint64 len)

// 将 (srcva, max) 拷贝到 (dst, max)，遇到 '\0' 停止
int copyinstr2(char *dst, uint64 srcva, uint64 max)
```
