# 结构体
```c
struct proc
{
    struct spinlock lock;

    // 自旋锁保护如下成员
    enum procstate state; // 进程状态
    struct proc *parent;  // 指向父进程
    void *chan;           // 等待在 chan 上
    int killed;           // If non-zero, have been killed
    int xstate;           // 进程退出时的状态码
    int pid;              // 进程 ID

    // these are private to the process, so p->lock need not be held.
    uint64 kstack;               // 内核堆栈的虚拟指针
    uint64 sz;                   // 进程的用户空间
    pagetable_t pagetable;       // User page table
    pagetable_t kpagetable;      // Kernel page table
    struct trapframe *trapframe; // trapframe 结构体
    struct context context;      // swtch() 对应的上下文
    struct file *ofile[NOFILE];  // 进程打开的文件
    struct dirent *cwd;          // Current directory
    char name[16];               // 进程名称
    int tmask;                   // trace 掩码
};

struct proc proc[NPROC];

struct cpu
{
    struct proc *proc;      // cpu 运行的进程
    struct context context; // 用于 swtch 切换 scheduler
    int noff;               // push_off 的深度
    int intena;             // push_off 前中断是否被打开
};

extern struct cpu cpus[NCPU];
```
# 功能函数
## 申请函数
```c
// 初始化保护 PID 和每个 proc 的自旋锁
void procinit(void)

// 获取一个 PID
int allocpid()

// 找到 UNUSED 的进程 p
// 为 p 分配用户页表和内核页表、内核堆栈
// 用户页表映射 TRAMPOLINE 和 TRAPFRAME
// 内核页表与原内核页表相同，但添加 VKSTACK 映射
// 初始化 swich 对应的上下文
static struct proc *allocproc(void)

// 创建一个新页表，映射 TRAMPOLINE 和 TRAPFRAME
pagetable_t proc_pagetable(struct proc *p)
```
## 释放函数
```C
// 释放页表（pagetable, sz）和其映射的物理页
// 取消 TRAMPOLINE、TRAPFRAME 映射，但不释放物理页
void proc_freepagetable(pagetable_t pagetable, uint64 sz)


// 释放 p 占用的所有资源
// p->trapframe、内核栈、内核页表本身
// 用户页和其映射的物理空间
static void freeproc(struct proc *p)
```
## 初始化函数
```C
// 分配一个 init 进程
// 分配一页物理页，将 initcode 程序拷贝到物理页中
// (pagetable, 0, sz) 和 (kpagetable, 0, sz) 都映射到该物理页
void userinit(void)

// fork 出来子进程的第一次 swtch 执行的函数
// 调用 usertrapret
void forkret(void)
```
## 进程管理函数
```C
// 增长或收缩进程的 用户页表和内核页表
// 对于 kpagetable 只取消映射、对于 pagetable 取消映射且释放物理页面
int growproc(int n)

// 从旧进程 fork 一个新进程
// 拷贝与旧进程一样的内存数据，并映射到 pagetable 和 kpagetable
// 拷贝 trapframe
int fork(void)

// fork 出来子进程的第一次 swtch 执行的函数
// 执行 usertrapret 返回用户空间
void forkret(void)

// 将 p 进程的子进程交由 init 进程管理
void reparent(struct proc *p)

// 关闭文件描述符
// 将 该进程的子进程 交由 init 进程管理
// 调用 sched 进入调度器
// 唤醒 initproc 和 该进程的父进程
void exit(int status)

// 等待一个子进程退出，转换为僵尸进程后回收他的资源
// 如果子进程均没有退出，就阻塞等待
// 如果没有子进程，则返回 -1
int wait(uint64 addr)

// 标记 pid 对应的 proc 为 killed状态
int kill(int pid)

// 将等待在 chan 上的进程唤醒
void wakeup(void *chan)

// 如果进程交由自身等待，则将其唤醒
void wakeup1(struct proc *p)
```
## 调度函数
```c
// 标记当前线程为 RUNNABLE
// 调用 sched() 切换上下文
void yield(void)

// 将当前 CPU 从 myproc 切换到 mycpu()->context
void sched(void)

// scheduler 循环寻找 RUNNABLE 的资源并进行调度
void scheduler(void)

// 将当前线程阻塞在 chan，并释放 lk，在唤醒时重新持有
void sleep(void *chan, struct spinlock *lk)
```
