# 结构体
```C
struct cpu
{
    struct proc *proc;      // cpu 运行的进程
    struct context context; // 用于 swtch 切换 scheduler
    int noff;               // push_off 的深度
    int intena;             // push_off 前中断是否被打开
};

struct spinlock
{
    uint locked;     // 是否上锁
    char *name;      // 自旋锁名称
    struct cpu *cpu; // 占有自旋锁的 cpu
};
```
# 接口函数
```C
// 初始化 spinlock
void initlock(struct spinlock *lk, char *name)
{
    lk->name = name;
    lk->locked = 0;
    lk->cpu = 0;
}

// 尝试获取自旋锁
void acquire(struct spinlock *lk)
{
    push_off();
    if (holding(lk))
        panic("acquire");

    while (__sync_lock_test_and_set(&lk->locked, 1) != 0)
        ;
    // 确保之前的操作已经完成，之后的操作不能被重新排序
    __sync_synchronize();
    lk->cpu = mycpu();
}

// 释放自旋锁
void release(struct spinlock *lk)
{
    if (!holding(lk))
        panic("release");

    lk->cpu = 0;
    __sync_synchronize();
    __sync_lock_release(&lk->locked);
    pop_off();
}

// 检查当前 CPU 是否拥有锁 lk
int holding(struct spinlock *lk)
{
    int r;
    r = (lk->locked && lk->cpu == mycpu());
    return r;
}

// 关闭中断
void push_off(void)
{
    int old = intr_get();

    intr_off();
    if (mycpu()->noff == 0)
        mycpu()->intena = old;
    mycpu()->noff += 1;
}

// 打开中断
void pop_off(void)
{
    struct cpu *c = mycpu();

    if (intr_get())
        panic("pop_off - interruptible");
	
    if (c->noff < 1)
    {
        panic("pop_off");
    }

    c->noff -= 1;
    if (c->noff == 0 && c->intena)
        intr_on();
}

```
