# 从内核陷入
## 初始化
- 设置 S 模式中断向量、启动 S 模式外部中断、软件中断、定时器中断
- 设置下次的定时时间
```C
void trapinithart(void)
{
    w_stvec((uint64)kernelvec);                      // S 模式的 trap 向量
    w_sstatus(r_sstatus() | SSTATUS_SIE);            // 允许 S 模式中断
    w_sie(r_sie() | SIE_SEIE | SIE_SSIE | SIE_STIE); // 启动 S 模式外部中断、软件中断、定时器中断
    set_next_timeout();                              // 设置下次的定时时间
}
```
## 跳入 kernelvec
```asm
.globl kerneltrap
.globl kernelvec
.align 4
kernelvec:
        addi sp, sp, -256
        sd ra, 0(sp)
		// ...

        call kerneltrap
```
## kerneltrap 处理
- 如果是软件中断、r_stval为 9（SBI外部中断转发）
	- UART_IRQ 则 读取串口字符，调用 consoleintr
	- DISK_IRQ 则 disk_intr
- 如果是 S 模式定时器中断，则 timer_tick、yield
## 从 kerneltrap 返回
```asm
	ld ra, 0(sp)
	// ...
	addi sp, sp, 256
	sret
```
# 从用户空间陷入
## 总结
- 蹦床页面存放用户态与内核态切换的汇编代码，`uservec`和`userret`
- `TRAPFRAME`每个进程单独拥有，存放寄存器快照
- 内核堆栈是进程在内核态的私有工作区

## 跳入汇编函数 uservec
- 在执行前，`sscratch`存放`TRAPFRAME`常量
- 在执行后，`sscratch`存放陷入前`a0`的值
```asm
	# 将寄存器保存到 TRAPFRAME
	csrrw a0, sscratch, a0
	sd ra, 40(a0)
	
	# 从 trapframe 中恢复寄存器
	ld sp, 8(a0)
	
	# 刷新页表
	csrw satp, t1
	sfence.vma
	
	# 跳入 usertrap
	jr t0 
```
## usertrap
- 如果是系统调用，执行对应的系统调用
- 尝试处理外部中断、定时器中断
- 如果是定时器中断，调用 yield
## usertrapret
```c
	// 设置 trap 向量
	w_stvec(TRAMPOLINE + (uservec - trampoline));
	
	// 保存寄存器到 p->trapframe
	p->trapframe->kernel_satp = r_satp();         // kernel page table
	p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
	p->trapframe->kernel_trap = (uint64)usertrap;
	p->trapframe->kernel_hartid = r_tp(); // hartid for cpuid()
	
	// 设置返回用户模式，打开中断
	unsigned long x = r_sstatus();
	x &= ~SSTATUS_SPP;
	x |= SSTATUS_SPIE;
	w_sstatus(x);
	
	// 更新 sepc
	w_sepc(p->trapframe->epc);
	
	// 调用 userret
	uint64 satp = MAKE_SATP(p->pagetable);
	uint64 fn = TRAMPOLINE + (userret - trampoline);
	((void (*)(uint64, uint64))fn)(TRAPFRAME, satp);
```
## 跳入汇编函数 userret
- 在执行前，`sscratch`存放陷入前`a0`的值
- 在执行后，`sscratch`存放`TRAPFRAME`
```asm
	# 更新页表
	csrw satp, a1
	sfence.vma

	# sscratch 用于暂存陷入内核时 trapframe 保存的 a0
    ld t0, 112(a0)
    csrw sscratch, t0
		
	# 从 trapframe 中恢复现场
	ld ra, 40(a0)
	......

	# 返回
	sret
```
## trapframe
```C
struct trapframe
{
  // T 为临时寄存器，函数调用时不需要保存
  // S 为保存寄存器，跨函数调用保持不变
  // A 为参数寄存器，用于传递函数参数
  /*   0 */ uint64 kernel_satp;   // 当前内核页表的地址
  /*   8 */ uint64 kernel_sp;     // 进程的内核栈顶地址
  /*  16 */ uint64 kernel_trap;   // 用户态进入到内核是要执行的 trap() 处理函数
  /*  24 */ uint64 epc;           // 用户态 PC
  /*  32 */ uint64 kernel_hartid; // cpu核心ID
  
  /*  40 */ uint64 ra;            // 返回地址寄存器
  /*  48 */ uint64 sp;            // 用户态栈指针
  /*  56 */ uint64 gp;            // 全局变量的基址
  /*  64 */ uint64 tp;            // 线程指针
  
  /*  72 */ uint64 t0;
  /*  80 */ uint64 t1;
  /*  88 */ uint64 t2;
  /*  96 */ uint64 s0;
  /* 104 */ uint64 s1;
  /* 112 */ uint64 a0;
  /* 120 */ uint64 a1;
  /* 128 */ uint64 a2;
  /* 136 */ uint64 a3;
  /* 144 */ uint64 a4;
  /* 152 */ uint64 a5;
  /* 160 */ uint64 a6;
  /* 168 */ uint64 a7;
  /* 176 */ uint64 s2;
  /* 184 */ uint64 s3;
  /* 192 */ uint64 s4;
  /* 200 */ uint64 s5;
  /* 208 */ uint64 s6;
  /* 216 */ uint64 s7;
  /* 224 */ uint64 s8;
  /* 232 */ uint64 s9;
  /* 240 */ uint64 s10;
  /* 248 */ uint64 s11;
  /* 256 */ uint64 t3;
  /* 264 */ uint64 t4;
  /* 272 */ uint64 t5;
  /* 280 */ uint64 t6;
};
```
