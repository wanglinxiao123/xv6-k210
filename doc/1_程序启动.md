# 内存分布
|段名|	内容类型|	初始化状态|	内存特性|	典型示例|
|--|--|--|--|--|
|.text|	可执行代码|	编译时确定|	只读|	函数、中断处理程序|
|.rodata|	只读数据|	编译时初始化|	只读|	字符串常量、数学常数|
|.data|	已初始化数据|	程序加载时初始化|	可读写|	全局变量、静态初始化变量|
|.bss|	未初始化数据|	程序加载时清零|	可读写	|未初始化全局变量、预留缓冲区|

# 汇编代码
1. `ld`脚本指定程序入口为`_start`，由`SBI`跳转
2. `entry_k210.S`开辟栈空间，设置核心的`SP`
```asm
    .section .text.entry
    .globl _start
_start:
	# a0 存储 Hart ID，由启动固件传入
	# t0 = (hart_id + 1) * 16KB
    add t0, a0, 1
    slli t0, t0, 14
	
	# 初始化每个核心的 sp 指针
	la sp, boot_stack
    add sp, sp, t0

	# 调转到 main函数
    call main

	# 死循环兜底
loop:
    j loop

	# .bss段，4KB对齐
	# 为每个核心分配 16KB
    .section .bss.stack
    .align 12
    .globl boot_stack
boot_stack:

    .space 4096 * 4 * 2

    .globl boot_stack_top
boot_stack_top:
```
3. 跳转到`main`函数，通过`ipi`唤醒其他核心
```c
for(int i = 1; i < NCPU; i++) {
  unsigned long mask = 1 << i;
  sbi_send_ipi(&mask);
}
```
