# 参数
```
[FAT32 init]byts_per_sec: 512
[FAT32 init]root_clus: 2
[FAT32 init]sec_per_clus: 32
[FAT32 init]fat_cnt: 2
// 每个 fat 表占用 0x3B80 扇区
[FAT32 init]fat_sz: 15232
[FAT32 init]first_data_sec: 30496
```
## 内存计算
- SD卡大小`32 GB`
- 一个扇区`512`字节
- 一簇`32`扇区，`16KB`
- 一共有`0x200000`个簇
- 一个簇占`4字节`，表示这么多簇要`0x200000 / 4 = 32768 字节`
# 代码
![](../img/3.jpg)
## 分区引导扇区（扇区0）
- 每扇区字节数
- 每簇扇区数
- 保留扇区数
- FAT 数量
- 每个 FAT 占用的扇区大小
## 保留扇区
## FAT表1
- 每个簇在 FAT 表中对应一个 4 字节的表项
## FAT表2
## 数据扇区
- 第一个数据扇区号：保留扇区数 + FAT 表数量 * 每个 FAT 占用的扇区大小
- 根目录起始簇号：直接从引导扇区获取
- 簇0和簇1保留、簇号从2开始
## 功能函数
```c
// 计算簇号 cluster 对应的第一个扇区号
static inline uint32 first_sec_of_clus(uint32 cluster)

// 找到 cluster 簇在第 fat_num FAT表中对应的扇区号
static inline uint32 fat_sec_of_clus(uint32 cluster, uint8 fat_num)

// 计算 cluster 簇在扇区中的偏移字节数
static inline uint32 fat_offset_of_clus(uint32 cluster)

// 根据当前簇号，从 FAT 表中读取下一个簇号
// 当前簇号->查找 FAT 表-> 4字节的下一个簇号
static uint32 read_fat(uint32 cluster)

// 将 FAT 表中的 cluster 簇的值写为 content
static int write_fat(uint32 cluster, uint32 content)

// 将 FAT 表对应的 cluster 簇下标写为 0
static void free_clus(uint32 cluster)

// 清零对应的簇
static void zero_clus(uint32 cluster)

// 遍历 FAT 表，找到空闲簇，在表中标记为已分配
// 清除数据扇区中对应的簇
static uint32 alloc_clus(uint8 dev)

// write = 1, 则将 (data, n) 写入到 (cluster, off, n)
// write = 0, 则将 (cluster, off, n) 写入到 (data, n)
static uint rw_clus(uint32 cluster, int write, int user, uint64 data, uint off, uint n)

// 找到目录项 entry 偏移 off 处的簇号
// 如果 off > 当前总簇数，则向后拓展
// 如果 off < 当前访问的簇数，则重新遍历
// alloc = 1 则分配空间
static int reloc_clus(struct dirent *entry, uint off, int alloc)
```
