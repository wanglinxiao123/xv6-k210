# 接口
```c
// 将内核或者用户空间的(src, n)输出到控制台
// user_src = 1 则为用户空间
int consolewrite(int user_src, uint64 src, int n)

// 从控制台读取 n 个数据到(dst, n)
// 没有数据时将会被阻塞
// user_dst = 1 则为用户空间
// 遇到文件末尾、换行符则返回
int consoleread(int user_dst, uint64 dst, int n)

// 处理串口输入的一个进程
// CTRL+P 打印进程列表
// CTRL+U 删除整行
// 回车回退一个字符
// 其他情况将字符填入缓冲区，遇见换行、文件末尾则更新写指针、唤醒进程
void consoleintr(int c)

// 初始化自旋锁
// 关联读写系统调用
void consoleinit(void)
```
# 结构体
```C
struct
{
  struct spinlock lock;
  char buf[INPUT_BUF];
  uint r; // 读指针
  uint w; // 写指针
  uint e; // 编辑指针
} cons;
```
# 函数
## 读写回调函数
```C
// 初始化自旋锁
// 关联读写系统调用
void consoleinit(void)
{
    initlock(&cons.lock, "cons");
    cons.e = cons.w = cons.r = 0;
    devsw[CONSOLE].read = consoleread;
    devsw[CONSOLE].write = consolewrite;
}

// 将内核或者用户空间的(src, n)输出到控制台
// user_src = 1 则为用户空间
int consolewrite(int user_src, uint64 src, int n)
{
    int i;
    acquire(&cons.lock);
    for (i = 0; i < n; i++)
    {
        char c;
        if (either_copyin(&c, user_src, src + i, 1) == -1)
            break;
        sbi_console_putchar(c);
    }
    release(&cons.lock);
    return i;
}

// 从控制台读取 n 个数据到(dst, n)
// user_dst = 1 则为用户空间
// 遇到文件末尾、换行符则返回
int consoleread(int user_dst, uint64 dst, int n)
{
  uint target;
  int c;
  char cbuf;

  target = n;
  acquire(&cons.lock);
  while (n > 0)
  {
    // 等待控制台输入数据
    while (cons.r == cons.w)
    {
      if (myproc()->killed)
      {
        release(&cons.lock);
        return -1;
      }
      sleep(&cons.r, &cons.lock);
    }

    // 获取一个字符
    c = cons.buf[cons.r++ % INPUT_BUF];

    // 如果读到了 ^D 就回退一个
    if (c == C('D'))
    {
      if (n < target)
      {
        cons.r--;
      }
      break;
    }

    // 从缓冲区拿一个字符
    cbuf = c;
    if (either_copyout(user_dst, dst, &cbuf, 1) == -1)
      break;

    dst++;
    --n;

    // 遇到换行符就弹出
    if (c == '\n')
    {
      break;
    }
  }
  release(&cons.lock);
  return target - n;
}
```
## 控制台中断函数
1. 定时器中断触发`timer_tick`
2. `timer_tick`从串口寄存器中读取一个字节
3. 调用`consoleintr`处理输入的字符
```C
// 通过 SBI putchar
void consputc(int c)
{
  sbi_console_putchar(c);
}

// 由中断程序调用，将输入字符添加到暂存区
void consoleintr(int c)
{
  acquire(&cons.lock);

  switch (c)
  {
  // CTRL+P 打印进程列表
  case C('P'):
    procdump();
    break;

  // CTRL+U 删除整行
  case C('U'):
    while (cons.e != cons.w && cons.buf[(cons.e - 1) % INPUT_BUF] != '\n')
    {
      cons.e--;
      consputc(BACKSPACE);
    }
    break;

  // CTRL+H 回退一个字符
  case C('H'):
  case '\x7f':
    if (cons.e != cons.w)
    {
      cons.e--;
      consputc(BACKSPACE);
    }
    break;

  default:
    if (c != 0 && cons.e - cons.r < INPUT_BUF)
    {
      // 跳过 '\r'
      if (c == '\r')
        break;

      // 回写控制台
      consputc(c);

      // cons.e++，字符写入 cons.buf
      cons.buf[cons.e++ % INPUT_BUF] = c;

      // 遇到换行、CTRL+D、缓冲区满则更新 cons.w
      if (c == '\n' || c == C('D') || cons.e == cons.r + INPUT_BUF)
      {
        cons.w = cons.e;
        wakeup(&cons.r);
      }
    }
    break;
  }

  release(&cons.lock);
}
```
# printf 接口
```C
static struct
{
  struct spinlock lock; // 同一时间只有一个进程使用printf
  int locking;          // 是否加锁保护
} pr;

// 初始化保护 printf 的结构体
void printfinit(void)
{
  initlock(&pr.lock, "pr");
  pr.locking = 1;
}

// 控制台格式化输出
void printf(char *fmt, ...)

// 输出 painc 提示，进入死循环
void panic(char *s)
```
